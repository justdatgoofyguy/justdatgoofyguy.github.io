<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adventure Runner</title>
    <style>
        html, body { height: 100%; }
        body {
            margin: 0;
            background: linear-gradient(135deg, #0ea5e9, #7c3aed);
            font-family: -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
            color: #111827;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .frame {
            background: #ffffffee;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.35);
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .title {
            margin: 0;
            text-align: center;
        }
        .wrap {
            position: relative;
            width: 960px;
            height: 540px;
            border-radius: 12px;
            overflow: hidden;
            border: 3px solid #334155;
            background: #0f172a;
        }
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }
        .hud {
            position: absolute; inset: 0; pointer-events: none; color: #e5e7eb;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        .topbar { display: flex; justify-content: space-between; padding: 10px 12px; font-weight: 700; }
        .controls { display: flex; gap: 8px; }
        .toggle {
            pointer-events: auto; cursor: pointer; border: none; padding: 6px 10px; border-radius: 999px; font-weight: 800;
            background: rgba(15,23,42,0.6); color: #e5e7eb; border: 1px solid #475569;
        }
        .pill { background: rgba(15,23,42,0.6); padding: 6px 10px; border-radius: 999px; border: 1px solid #475569; }
        .help { position: absolute; left: 12px; bottom: 12px; background: rgba(15,23,42,0.7); border: 1px solid #475569; border-radius: 10px; padding: 10px; max-width: 60%; line-height: 1.4; }
        .center { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; }
        .modal { pointer-events: auto; background: #ffffff; color: #111827; padding: 28px 22px; border-radius: 14px; box-shadow: 0 12px 40px rgba(0,0,0,0.35); text-align: center; min-width: 300px; }
        .modal h2 { margin: 0 0 10px 0; }
        .btn {
            pointer-events: auto; cursor: pointer; border: none; padding: 10px 16px; border-radius: 10px; font-weight: 800;
            background: linear-gradient(135deg, #22c55e, #16a34a); color: white; box-shadow: 0 8px 24px rgba(22,163,74,0.35);
        }
        .btn:hover { transform: translateY(-1px); }
    </style>
    <!-- Controls: Arrow keys/WASD to move and jump. Space to jump. R to restart. -->
    <!-- Game: Reach the flag at the far right. Collect all 10 coins for a bonus. Avoid spikes and enemies. -->
    <!-- Performance: Single canvas, tile collisions, simple physics, requestAnimationFrame loop. -->
    <!-- License: You may use and modify freely. -->
    </head>
<body>
    <div class="frame">
        <h2 class="title">Adventure Runner</h2>
        <div class="wrap">
            <canvas id="game"></canvas>
            <div class="hud">
                <div class="topbar">
                    <div class="pill" id="hudLeft">HP: 3 | Coins: 0/10</div>
                    <div class="controls">
                        <button class="toggle" id="musicBtn" aria-pressed="false" title="Toggle Music">♪ Music: Off</button>
                        <div class="pill" id="hudRight">Time: 0.0s</div>
                    </div>
                </div>
                <div class="help">
                    Move: A/D or ←/→, Jump: W/Space or ↑, Drop: S or ↓, Reset: T, Restart: R
                </div>
            </div>
            <div class="center" id="overlay" style="display:none;">
                <div class="modal">
                    <h2 id="overlayTitle">You Win!</h2>
                    <div id="overlayMsg">Great run.</div>
                    <div style="height: 10px;"></div>
                    <button class="btn" id="restartBtn">Play Again</button>
                </div>
            </div>
        </div>
    </div>
    <script>
    (function(){
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const W = 960, H = 540;
        canvas.width = W; canvas.height = H;

        // World units
        const TILE = 32; // 32px tile grid
        const GRAVITY = 1800; // px/s^2
        const MOVE_SPEED = 320; // px/s
        const JUMP_SPEED = 700; // px/s
        const MAX_FALL = 900;
        // Cannon tuning
        const CANNON_RANGE_X = 420;
        const CANNON_RANGE_Y = 160;
        const CANNON_COOLDOWN_MIN = 1.0;
        const CANNON_COOLDOWN_MAX = 2.0;
        const CANNONBALL_SPEED = 460;
        const CANNONBALL_RADIUS = 6;

        // Camera
        const camera = { x: 0, y: 0 };

        // Input
        const keys = new Set();
        const held = (k) => keys.has(k);
        window.addEventListener('keydown', (e)=>{ keys.add(e.key.toLowerCase()); if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault(); });
        window.addEventListener('keyup',   (e)=>{ keys.delete(e.key.toLowerCase()); });

        // Level definition: simple array of objects
        // Tiles: 0 empty, 1 ground, 2 platform (one-way), 3 spike, 4 wall, 5 spring
        // Entities: player, enemy (patrol), coin; endless mode (no goal)
        const level = buildLevel();

        const state = {
            coins: 0,
            totalCoins: level.coins.length,
            hp: 3,
            timeStart: performance.now(),
            win: false,
            lose: false,
            loseAnimating: false
        };

        const player = {
            x: level.spawn.x,
            y: level.spawn.y,
            w: 24,
            h: 28,
            vx: 0,
            vy: 0,
            onGround: false,
            facing: 1,
        };

        const enemies = level.enemies.map(e=>({ ...e, vx: e.speed, vy: 0, w: 28, h: 28 }));
        const coins = level.coins.map(c=>({ ...c, taken:false }));
        const goal = level.goal;
        
        // Cannons and cannonballs
        const cannons = level.cannons.map(c=>({ x:c.x, y:c.y, w:28, h:28, cooldown: 0, facing: 1, flashT:0 }));
        const cannonBalls = [];
        const cannonSmoke = [];
        // Eater animation state when killed by enemy
        const eater = { active:false, src:null, x:0, y:0, baseW:28, baseH:28, w:28, h:28, phase:'grow', t:0, sx:0, sy:0, targetX:0, targetY:0 };
        // Spike death FX and persistent blood decals
        const bloodDecals = []; // {x,y,r,a}
        const spikeFx = { active:false, t:0, duration:0.9, particles:[], x:0, y:0 };

        const hudLeft = document.getElementById('hudLeft');
        const hudRight = document.getElementById('hudRight');
        const musicBtn = document.getElementById('musicBtn');
        const overlay = document.getElementById('overlay');
        const overlayTitle = document.getElementById('overlayTitle');
        const overlayMsg = document.getElementById('overlayMsg');
        const restartBtn = document.getElementById('restartBtn');
        restartBtn.addEventListener('click', ()=> restart());

        // Music engine (Web Audio)
        let audioCtx = null;
        let musicNodes = null;
        let musicOn = false;
        let resumeOnGesture = false;

        function initAudio(){
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function startMusic(){
            initAudio();
            if (!audioCtx) return;
            if (audioCtx.state === 'suspended') { audioCtx.resume(); }
            if (musicNodes) { return; }
            // Create a simple chiptune-like loop: bass + lead arpeggio + noise hat
            const tempo = 108; // BPM
            const beat = 60 / tempo; // seconds per beat
            const barBeats = 4;
            const barDur = beat * barBeats;

            const master = audioCtx.createGain();
            master.gain.value = 0.18;
            master.connect(audioCtx.destination);

            // Bass sequence (root-minor walk)
            const bass = audioCtx.createGain();
            bass.gain.value = 0.7;
            bass.connect(master);

            const bassOsc = audioCtx.createOscillator();
            bassOsc.type = 'square';
            bassOsc.connect(bass);

            // Lead
            const lead = audioCtx.createGain();
            lead.gain.value = 0.35;
            lead.connect(master);

            const leadOsc = audioCtx.createOscillator();
            leadOsc.type = 'square';
            leadOsc.connect(lead);

            // Hat (noise)
            const hat = audioCtx.createGain();
            hat.gain.value = 0.05;
            hat.connect(master);

            // Sequencing helpers
            const now = audioCtx.currentTime + 0.02;
            const root = 196.00; // G3
            const minor = [0, 3, 7, 10];

            function setFreqParam(param, t, freq){ param.setValueAtTime(freq, t); }
            function env(g, t, a, d, s){
                g.gain.cancelScheduledValues(t);
                g.gain.setValueAtTime(0.0001, t);
                g.gain.linearRampToValueAtTime(1.0, t + a);
                g.gain.linearRampToValueAtTime(s, t + a + d);
            }

            // Program 4 bars and loop by reprogramming every bar using setInterval
            const scheduleWindow = 2.0;
            let scheduledUntil = now;

            function noteToFreq(base, semi){ return base * Math.pow(2, semi/12); }

            function schedule(fromTime){
                const endTime = fromTime + scheduleWindow;
                while (scheduledUntil < endTime) {
                    const barStart = scheduledUntil;
                    // Bass: 8th notes walking: root, root, m3, m3, 5th, 5th, m7, m7
                    const bassSteps = [0,0,3,3,7,7,10,10];
                    for (let i=0;i<bassSteps.length;i++){
                        const t = barStart + i*(beat/2);
                        const f = noteToFreq(root, bassSteps[i]);
                        setFreqParam(bassOsc.frequency, t, f);
                        env(bass, t, 0.005, 0.12, 0.0001);
                    }

                    // Lead: simple 16th arpeggio pattern over chord tones
                    const arp = [0,7,3,7, 0,10,7,10, 0,7,3,7, 0,10,7,10];
                    for (let i=0;i<arp.length;i++){
                        const t = barStart + i*(beat/4);
                        const f = noteToFreq(root*2, arp[i]);
                        setFreqParam(leadOsc.frequency, t, f);
                        env(lead, t, 0.002, 0.08, 0.0001);
                    }

                    // Hats on 8ths
                    for (let i=0;i<8;i++){
                        const t = barStart + i*(beat/2);
                        // short noise burst
                        const buffSize = 2048;
                        const noiseBuf = audioCtx.createBuffer(1, buffSize, audioCtx.sampleRate);
                        const data = noiseBuf.getChannelData(0);
                        for (let n=0;n<buffSize;n++) data[n] = (Math.random()*2-1) * Math.exp(-n/180);
                        const noise = audioCtx.createBufferSource();
                        noise.buffer = noiseBuf;
                        const hatVca = audioCtx.createGain();
                        hatVca.gain.value = 0.0;
                        noise.connect(hatVca);
                        hatVca.connect(hat);
                        noise.start(t);
                        hatVca.gain.setValueAtTime(0.6, t);
                        hatVca.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
                        noise.stop(t + 0.06);
                    }

                    scheduledUntil += barDur;
                }
            }

            bassOsc.start(now);
            leadOsc.start(now);
            schedule(now);
            const interval = setInterval(()=>{
                if (!audioCtx || audioCtx.state !== 'running') return;
                schedule(audioCtx.currentTime);
            }, Math.max(120, beat*1000));

            musicNodes = { master, bass, lead, hat, bassOsc, leadOsc, interval };
            musicOn = true;
            updateMusicBtn();
        }

        function stopMusic(){
            if (!musicNodes) { musicOn = false; updateMusicBtn(); return; }
            const { master, bassOsc, leadOsc, interval } = musicNodes;
            try { bassOsc.stop(); } catch(e){}
            try { leadOsc.stop(); } catch(e){}
            if (interval) clearInterval(interval);
            if (master) master.gain.exponentialRampToValueAtTime(0.0001, (audioCtx?audioCtx.currentTime:0) + 0.08);
            musicNodes = null;
            musicOn = false;
            updateMusicBtn();
        }

        function toggleMusic(){
            if (musicOn) stopMusic(); else startMusic();
            try { localStorage.setItem('adv_music', musicOn ? 'on' : 'off'); } catch(e){}
        }

        function updateMusicBtn(){
            if (!musicBtn) return;
            musicBtn.setAttribute('aria-pressed', musicOn ? 'true' : 'false');
            musicBtn.textContent = `♪ Music: ${musicOn ? 'On' : 'Off'}`;
        }

        musicBtn.addEventListener('click', (e)=>{
            toggleMusic();
        });

        function restart() {
            const fresh = buildLevel();
            player.x = fresh.spawn.x; player.y = fresh.spawn.y; player.vx=player.vy=0; player.onGround=false; player.facing=1;
            enemies.length = 0; fresh.enemies.forEach(e=>enemies.push({ ...e, vx: e.speed, vy: 0, w:28, h:28 }));
            coins.length = 0; fresh.coins.forEach(c=>coins.push({ ...c, taken:false }));
            level.tiles = fresh.tiles; level.width = fresh.width; level.height=fresh.height; level.oneWays = fresh.oneWays; level.solids = fresh.solids;
            goal.x = fresh.goal.x; goal.y = fresh.goal.y;
            cannons.length = 0; fresh.cannons.forEach(c=>cannons.push({ x:c.x, y:c.y, w:28, h:28, cooldown:0, facing:1, flashT:0 }));
            cannonBalls.length = 0;
            cannonSmoke.length = 0;
            state.coins = 0; state.totalCoins = coins.length; state.hp = 3; state.timeStart = performance.now(); state.win=false; state.lose=false;
            overlay.style.display = 'none';
        }

        function resetPlayer(){
            // Reset only the player to spawn without rebuilding the level
            player.x = level.spawn.x;
            player.y = level.spawn.y;
            player.vx = 0;
            player.vy = 0;
            player.onGround = false;
            player.facing = 1;
        }

        // Helpers
        function tileAt(px, py) {
            const tx = Math.floor(px / TILE), ty = Math.floor(py / TILE);
            if (tx < 0 || ty < 0 || tx >= level.width || ty >= level.height) return 1; // treat outside as solid wall/ground
            return level.tiles[ty * level.width + tx];
        }
        function rectVsRect(a, b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
        function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

        function update(dt) {
            if (state.win || state.lose) return;
            // Input
            const left = held('a') || held('arrowleft');
            const right = held('d') || held('arrowright');
            const up = held('w') || held('arrowup') || held(' ');
            const down = held('s') || held('arrowdown');

            // Horizontal
            player.vx = 0;
            if (left) { player.vx = -MOVE_SPEED; player.facing = -1; }
            if (right){ player.vx =  MOVE_SPEED; player.facing =  1; }

            // Gravity
            player.vy += GRAVITY * dt;
            player.vy = clamp(player.vy, -Infinity, MAX_FALL);

            // Jump (coyote time and buffered not implemented; simple onGround jump)
            if (up && player.onGround) {
                player.vy = -JUMP_SPEED;
            }
            if (down && player.vy < 0) {
                player.vy *= 0.6; // short hop
            }

            if (!state.loseAnimating) {
                // Move X with collision against solid tiles
                moveAxis(player, dt, 'x');
                // Move Y with collision, supporting one-way platforms when falling down
                // Spring bounce: if feet overlapped a spring tile while moving down, boost upward
                const beforeVy = player.vy;
                moveAxis(player, dt, 'y');
                
                if (beforeVy > 200) {
                    const footY = player.y + player.h + 1;
                    const txL = Math.floor((player.x + 4) / TILE);
                    const txR = Math.floor((player.x + player.w - 4) / TILE);
                    const ty = Math.floor(footY / TILE);
                    const idxL = ty * level.width + txL;
                    const idxR = ty * level.width + txR;
                    const isSpring = (level.tiles[idxL] === 5) || (level.tiles[idxR] === 5);
                    if (isSpring) {
                        player.vy = -JUMP_SPEED * 1.25;
                        player.onGround = false;
                    }
                }
            }

            // Cannons: fire at nearby player
            for (let i=0;i<cannons.length;i++){
                const c = cannons[i];
                if (state.loseAnimating) continue;
                c.cooldown = Math.max(0, c.cooldown - dt);
                c.flashT = Math.max(0, c.flashT - dt);
                const pcx = player.x + player.w/2;
                const pcy = player.y + player.h/2;
                const ccx = c.x + c.w/2;
                const ccy = c.y + c.h/2;
                const dx = pcx - ccx;
                const dy = pcy - ccy;
                const adx = Math.abs(dx);
                const ady = Math.abs(dy);
                c.facing = dx >= 0 ? 1 : -1;
                if (adx < CANNON_RANGE_X && ady < CANNON_RANGE_Y && c.cooldown === 0) {
                    const len = Math.max(1, Math.hypot(dx, dy));
                    const speed = CANNONBALL_SPEED;
                    const vx = (dx/len) * speed;
                    const vy = (dy/len) * speed;
                    const mouthX = ccx + (c.facing>0 ? c.w/2 : -c.w/2);
                    const mouthY = ccy - 4;
                    cannonBalls.push({ x: mouthX, y: mouthY, vx, vy, r: CANNONBALL_RADIUS, alive: true });
                    // muzzle flash
                    c.flashT = 0.12;
                    // smoke puffs
                    const puffCount = 3 + Math.floor(Math.random()*3);
                    for (let p=0;p<puffCount;p++){
                        const ang = Math.atan2(vy, vx) + (Math.random()*0.4 - 0.2);
                        const spd = 60 + Math.random()*80;
                        cannonSmoke.push({ x: mouthX, y: mouthY, vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd, r: 3+Math.random()*3, a: 0.9, life: 0.5+Math.random()*0.3 });
                    }
                    c.cooldown = CANNON_COOLDOWN_MIN + Math.random()*(CANNON_COOLDOWN_MAX - CANNON_COOLDOWN_MIN);
                }
            }

            // Cannonballs update and collisions
            for (let i=0;i<cannonBalls.length;i++){
                const b = cannonBalls[i];
                if (!b.alive) continue;
                if (!state.loseAnimating) {
                    b.x += b.vx * dt;
                    b.y += b.vy * dt;
                }
                // Tile collision
                const t = tileAt(b.x, b.y);
                if (t === 1 || t === 4) { b.alive = false; continue; }
                // Player collision
                const br = { x: b.x - b.r, y: b.y - b.r, w: b.r*2, h: b.r*2 };
                if (!state.loseAnimating && rectVsRect(player, br)) {
                    // Player explosion similar to spike death
                    spawnSpikeFx(player.x + player.w/2, player.y + player.h/2);
                    state.loseAnimating = true;
                    b.alive = false;
                    setTimeout(()=>{
                        state.loseAnimating = false;
                        state.lose = true;
                        showOverlay('Game Over', `Blasted by a cannon! Coins: ${state.coins}/${state.totalCoins}`);
                    }, 900);
                }
                
            }

            // Smoke update
            for (let i=0;i<cannonSmoke.length;i++){
                const s = cannonSmoke[i];
                s.life -= dt;
                if (s.life <= 0) { cannonSmoke.splice(i,1); i--; continue; }
                s.x += s.vx * dt;
                s.y += s.vy * dt;
                s.vx *= 0.96;
                s.vy *= 0.96;
                s.a *= 0.96;
            }

            // Enemies: simple patrol, flip on wall/edge
            for (let i=0;i<enemies.length;i++){
                const e = enemies[i];
                if (state.loseAnimating) { continue; }
                // apply gravity
                e.vy += GRAVITY * dt;
                e.vy = clamp(e.vy, -Infinity, MAX_FALL);
                // horizontal move with basic feelers
                const nextX = e.x + e.vx * dt;
                const feetY = e.y + e.h + 1;
                const aheadX = nextX + (e.vx>0? e.w+1 : -1);
                const floorAhead = tileAt(aheadX, feetY);
                const wallAhead = tileAt(aheadX, e.y + e.h/2);
                if (wallAhead === 1 || wallAhead === 4 || floorAhead === 0) {
                    e.vx = -e.vx;
                }
                e.x += e.vx * dt;
                // vertical with ground collision
                e.y += e.vy * dt;
                if (solidAtRect(e)) {
                    // simple resolve: push up while intersecting
                    while (solidAtRect(e)) { e.y -= 1; }
                    e.vy = 0;
                }
                // Touch damage
                if (rectVsRect(player, e)) hurt('enemy', e);
            }

            

            // Coins
            for (let i=0;i<coins.length;i++){
                const c = coins[i]; if (c.taken) continue;
                const rc = { x:c.x+6, y:c.y+6, w:20, h:20 };
                if (!state.loseAnimating && rectVsRect(player, rc)) { c.taken = true; state.coins++; }
            }

            // Spikes/hazards (endless mode)
            const spike = touchingSpike(player);
            if (!state.loseAnimating && spike) hurt('spike');

            // Camera follow
            camera.x = clamp(player.x + player.w/2 - W/2, 0, level.width*TILE - W);
            camera.y = clamp(player.y + player.h/2 - H/2, 0, level.height*TILE - H);

            // Restart key
            if (held('r')) restart();
            // Reset player key
            if (held('t')) resetPlayer();

            // Eater death animation update
            if (state.loseAnimating && eater.active) {
                eater.t += dt;
                const growDur = 0.6, chaseDur = 0.5, eatDur = 0.6;
                if (eater.phase === 'grow') {
                    if (eater.t >= growDur) {
                        eater.phase = 'chase';
                        eater.t = 0;
                        eater.sx = eater.x; eater.sy = eater.y;
                    }
                } else if (eater.phase === 'chase') {
                    const tt = clamp(eater.t / chaseDur, 0, 1);
                    eater.x = eater.sx + (eater.targetX - eater.sx) * tt;
                    eater.y = eater.sy + (eater.targetY - eater.sy) * tt;
                    if (eater.t >= chaseDur) { eater.phase = 'eat'; eater.t = 0; }
                } else if (eater.phase === 'eat') {
                    if (eater.t >= eatDur) {
                        state.loseAnimating = false;
                        state.lose = true;
                        showOverlay('Game Over', `Try again — Coins: ${state.coins}/${state.totalCoins}`);
                    }
                }
            }
            // Spike FX update
            if (spikeFx.active) {
                spikeFx.t += dt;
                const g = 2200;
                for (let i=0;i<spikeFx.particles.length;i++){
                    const p = spikeFx.particles[i];
                    if (!p.alive) continue;
                    p.vy += g * dt;
                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                    p.life -= dt;
                    if (p.y + p.r >= p.floorY) {
                        // splat and create decal
                        p.alive = false;
                        bloodDecals.push({ x:p.x, y:p.floorY-2, r: Math.max(2, p.r*1.2), a: 0.9 });
                    }
                    if (p.life <= 0) p.alive = false;
                }
                if (spikeFx.t >= spikeFx.duration) spikeFx.active = false;
            }
        }

        function hurt(sourceType, sourceObj){
            state.hp--;
            if (state.hp <= 0) {
                if (sourceType === 'enemy' && sourceObj && !state.loseAnimating) {
                    // Start eater sequence
                    state.loseAnimating = true;
                    eater.active = true;
                    eater.src = sourceObj;
                    eater.x = sourceObj.x; eater.y = sourceObj.y;
                    eater.baseW = sourceObj.w; eater.baseH = sourceObj.h; eater.w = eater.baseW; eater.h = eater.baseH;
                    eater.phase = 'grow'; eater.t = 0;
                    eater.targetX = player.x; eater.targetY = player.y;
                    // freeze player motion
                    player.vx = 0; player.vy = 0; player.onGround = true;
                } else if (sourceType === 'spike' && !state.loseAnimating) {
                    // Start spike explosion FX
                    spawnSpikeFx(player.x + player.w/2, player.y + player.h/2);
                    // Immediately respawn or set lose if out of lives handled by hp<=0
                    // Freeze rendering of player during explosion by setting a brief anim state
                    state.loseAnimating = true; // reuse flag to pause gameplay briefly
                    setTimeout(()=>{
                        state.loseAnimating = false;
                        state.lose = true;
                        showOverlay('Game Over', `You were spiked! Coins: ${state.coins}/${state.totalCoins}`);
                    }, 900);
                } else {
                    state.lose = true;
                    showOverlay('Game Over', `Try again — Coins: ${state.coins}/${state.totalCoins}`);
                }
            } else {
                // respawn at last safe ground near spawn
                player.x = level.spawn.x; player.y = level.spawn.y; player.vx=player.vy=0; player.onGround=false;
            }
        }

        function spawnSpikeFx(cx, cy){
            spikeFx.active = true; spikeFx.t = 0; spikeFx.particles = []; spikeFx.x = cx; spikeFx.y = cy;
            const count = 28;
            for (let i=0;i<count;i++){
                const angle = Math.random()*Math.PI*2;
                const speed = 300 + Math.random()*500;
                const r = 2 + Math.random()*4;
                spikeFx.particles.push({
                    x: cx, y: cy,
                    vx: Math.cos(angle)*speed,
                    vy: Math.sin(angle)*speed - 200,
                    r,
                    life: 0.8 + Math.random()*0.4,
                    alive: true,
                    floorY: Math.floor((cy+80)/TILE)*TILE // approximate nearby floor line
                });
            }
        }

        function showOverlay(title, msg){
            overlayTitle.textContent = title;
            overlayMsg.textContent = msg;
            overlay.style.display = 'flex';
        }

        function timeText(){
            return ((performance.now() - state.timeStart)/1000).toFixed(1) + 's';
        }

        function moveAxis(body, dt, axis){
            if (axis === 'x'){
                body.x += body.vx * dt;
                if (solidAtRect(body)){
                    // push out
                    const step = Math.sign(body.vx) || 1;
                    while (solidAtRect(body)) body.x -= step;
                    body.vx = 0;
                }
            } else {
                body.y += body.vy * dt;
                const wasFalling = body.vy > 0;
                // Handle one-way platforms: only collide if falling and feet above platform top
                if (solidAtRect(body, wasFalling)){
                    const step = Math.sign(body.vy) || 1;
                    while (solidAtRect(body, wasFalling)) body.y -= step;
                    if (body.vy > 0) { body.onGround = true; body.vy = 0; }
                    else { body.vy = 0; }
                } else {
                    body.onGround = false;
                }
            }
        }

        function solidAtRect(r, considerOneWay){
            // Sample a few points around rectangle edges
            const points = [
                {x:r.x, y:r.y}, {x:r.x+r.w, y:r.y}, {x:r.x, y:r.y+r.h}, {x:r.x+r.w, y:r.y+r.h},
                {x:r.x+r.w/2, y:r.y}, {x:r.x+r.w/2, y:r.y+r.h}
            ];
            for (let i=0;i<points.length;i++){
                const p = points[i];
                const t = tileAt(p.x, p.y);
                if (t === 1 || t === 4) return true; // solid
                if (t === 2 && considerOneWay) {
                    // one-way: collide only if moving downward and feet crossing the visible platform top
                    const tileTop = Math.floor(p.y / TILE) * TILE;
                    const platformTop = tileTop + TILE - 6; // platform is rendered as a 6px strip at bottom
                    const feet = r.y + r.h;
                    if (r.vy >= 0 && feet >= platformTop && feet - r.vy * (1/60) <= platformTop + 6) return true;
                }
            }
            return false;
        }

        function touchingSpike(r){
            // detect spike tiles under feet
            const footY = r.y + r.h - 2;
            const t1 = tileAt(r.x+4, footY);
            const t2 = tileAt(r.x+r.w-4, footY);
            return t1 === 3 || t2 === 3;
        }

        

        // RENDER
        function draw(){
            ctx.clearRect(0,0,W,H);
            ctx.save();
            ctx.translate(-Math.floor(camera.x), -Math.floor(camera.y));

            // Sky gradient
            const sky = ctx.createLinearGradient(0,0,0, H);
            sky.addColorStop(0,'#0ea5e9'); sky.addColorStop(1,'#1e293b');
            ctx.fillStyle = sky; ctx.fillRect(camera.x, camera.y, W, H);

            // Tiles
            for (let y=0;y<level.height;y++){
                for (let x=0;x<level.width;x++){
                    const t = level.tiles[y*level.width+x]; if (!t) continue;
                    const px = x*TILE, py = y*TILE;
                    if (t===1||t===4){
                        // ground/wall block
                        ctx.fillStyle = t===1? '#334155' : '#475569';
                        ctx.fillRect(px, py, TILE, TILE);
                        // top highlight
                        ctx.fillStyle = '#64748b';
                        ctx.fillRect(px, py, TILE, 4);
                    } else if (t===2){
                        // one-way
                        ctx.fillStyle = '#94a3b8';
                        ctx.fillRect(px, py+TILE-6, TILE, 6);
                    } else if (t===3){
                        // spikes
                        ctx.fillStyle = '#e11d48';
                        ctx.beginPath();
                        for (let i=0;i<4;i++){
                            const bx = px + i*(TILE/4);
                            ctx.moveTo(bx, py+TILE);
                            ctx.lineTo(bx+TILE/8, py+TILE-12);
                            ctx.lineTo(bx+TILE/4, py+TILE);
                        }
                        ctx.fill();
                    } else if (t===5){
                        // spring
                        ctx.fillStyle = '#22c55e';
                        ctx.fillRect(px+6, py+TILE-10, TILE-12, 10);
                    }
                }
            }

            // Coins
            coins.forEach(c=>{
                if (c.taken) return;
                const t = (performance.now()/400)%1;
                const bob = Math.sin(t*Math.PI*2)*3;
                ctx.fillStyle = '#f59e0b';
                ctx.beginPath();
                ctx.arc(c.x+TILE/2, c.y+TILE/2-6+bob, 8, 0, Math.PI*2);
                ctx.fill();
            });

            // Blood decals (persistent)
            for (let i=0;i<bloodDecals.length;i++){
                const b = bloodDecals[i];
                ctx.fillStyle = `rgba(153, 27, 27, ${b.a})`;
                ctx.beginPath();
                ctx.ellipse(b.x, b.y, b.r*1.2, b.r*0.6, 0, 0, Math.PI*2);
                ctx.fill();
            }

            // No goal flag in endless mode

            // Enemies
            enemies.forEach(e=>{
                // If this enemy is the eater during animation, draw special mouth
                const isEater = state.loseAnimating && eater.active && eater.src === e;
                if (isEater) {
                    drawEater(ctx, eater);
                } else {
                    ctx.fillStyle = '#ef4444';
                    ctx.fillRect(e.x, e.y, e.w, e.h);
                    // eyes
                    ctx.fillStyle = '#0f172a';
                    ctx.fillRect(e.x+6, e.y+10, 6, 6);
                    ctx.fillRect(e.x+e.w-12, e.y+10, 6, 6);
                }
            });

            // Cannons
            cannons.forEach(c=>{
                // Base
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(c.x, c.y, c.w, c.h);
                // Barrel
                ctx.fillStyle = '#9ca3af';
                const bx = c.facing>0 ? c.x + c.w - 4 : c.x - 12;
                const by = c.y + c.h/2 - 5;
                ctx.fillRect(bx, by, 12, 10);
                // Muzzle flash
                if (c.flashT > 0) {
                    const fx = c.facing>0 ? bx + 12 : bx;
                    const fy = by + 5;
                    const fr = 6 * (c.flashT/0.12);
                    const grad = ctx.createRadialGradient(fx, fy, 0, fx, fy, fr);
                    grad.addColorStop(0, 'rgba(255,255,200,0.9)');
                    grad.addColorStop(1, 'rgba(255,180,0,0.0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(fx, fy, fr, 0, Math.PI*2);
                    ctx.fill();
                }
            });

            // Cannonballs
            for (let i=0;i<cannonBalls.length;i++){
                const b = cannonBalls[i];
                if (!b.alive) continue;
                ctx.fillStyle = '#6b7280';
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
                ctx.fill();
            }

            // Smoke puffs
            for (let i=0;i<cannonSmoke.length;i++){
                const s = cannonSmoke[i];
                ctx.fillStyle = `rgba(148,163,184,${s.a})`;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
                ctx.fill();
            }

            

            // Player (shrink if being eaten or hide during spike explosion)
            let eatenScale = 1;
            const isSpikeExplosion = spikeFx.active && state.loseAnimating && !eater.active;
            if (state.loseAnimating && eater.active && eater.phase === 'eat') {
                const eatT = clamp(eater.t / 0.6, 0, 1);
                eatenScale = 1 - eatT;
            }
            if (!isSpikeExplosion) {
                const pw = player.w * eatenScale;
                const ph = player.h * eatenScale;
                const px = player.x + (player.w - pw)/2;
                const py = player.y + (player.h - ph)/2;
                ctx.fillStyle = '#22d3ee';
                ctx.fillRect(px, py, pw, ph);
                ctx.fillStyle = '#0f172a';
                ctx.fillRect(px + (player.facing>0? pw-10 : 4), py + 8*eatenScale, 6, 6);
            }

            // Spike explosion particles
            if (spikeFx.active) {
                for (let i=0;i<spikeFx.particles.length;i++){
                    const p = spikeFx.particles[i];
                    if (!p.alive) continue;
                    ctx.fillStyle = '#b91c1c';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
                    ctx.fill();
                }
            }

            ctx.restore();

            // HUD text
            hudLeft.textContent = `HP: ${state.hp} | Coins: ${state.coins}/${state.totalCoins}`;
            hudRight.textContent = `Time: ${timeText()}`;
        }

        // Main Loop
        let last = performance.now();
        function frame(now){
            const dt = Math.min(1/30, (now - last)/1000);
            last = now;
            update(dt);
            draw();
            requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);

        // Music: gesture unlock + preference load
        (function(){
            let pref = 'on';
            try { pref = localStorage.getItem('adv_music') || 'on'; } catch(e){}
            if (pref === 'on') {
                // Defer actual audio start until we have a user gesture
                resumeOnGesture = true;
                updateMusicBtn();
            } else {
                musicOn = false;
                updateMusicBtn();
            }
            function onFirstGesture(){
                if (!resumeOnGesture) return;
                resumeOnGesture = false;
                startMusic();
                try { localStorage.setItem('adv_music', 'on'); } catch(e){}
                window.removeEventListener('pointerdown', onFirstGesture);
                window.removeEventListener('keydown', onFirstGesture);
            }
            window.addEventListener('pointerdown', onFirstGesture, { once:false });
            window.addEventListener('keydown', onFirstGesture, { once:false });

            // Handle page visibility and audio context suspension
            document.addEventListener('visibilitychange', ()=>{
                if (!audioCtx) return;
                if (document.hidden) {
                    audioCtx.suspend && audioCtx.suspend();
                } else {
                    audioCtx.resume && audioCtx.resume();
                }
            });
        })();

        // Level builder
        function buildLevel(){
            const width = 240, height = 22; // endless-style wide world
            const tiles = new Array(width*height).fill(0);

            // Base ground with rolling noise
            for (let x=0;x<width;x++){
                const baseH = 16 + Math.floor(Math.sin(x*0.1)*2 + Math.sin(x*0.05)*2);
                for (let y=baseH;y<height;y++) tiles[y*width+x] = 1;
            }

            // Random platforms (one-way)
            const oneWays = [];
            function placePlatform(x,y,len){ for (let i=0;i<len;i++){ if (x+i>=0 && x+i<width) { tiles[y*width + (x+i)] = 2; oneWays.push({x:(x+i)*TILE, y:y*TILE, w:TILE, h:6}); } } }
            for (let i=0;i<60;i++){
                const px = 4 + Math.floor(Math.random()*(width-8));
                const py = 6 + Math.floor(Math.random()*10);
                const len = 3 + Math.floor(Math.random()*6);
                placePlatform(px, py, len);
            }

            // Random walls/columns
            for (let i=0;i<22;i++){
                const wx = 6 + Math.floor(Math.random()*(width-12));
                const wy = 8 + Math.floor(Math.random()*8);
                const h = 3 + Math.floor(Math.random()*6);
                for (let y=wy;y<Math.min(height-1, wy+h);y++) tiles[y*width+wx] = 4;
            }

            // Random spikes patches on ground
            function spikes(x,y,len){ for (let i=0;i<len;i++){ if (x+i>=0 && x+i<width) tiles[y*width + (x+i)] = 3; } }
            for (let i=0;i<20;i++){
                const sx = 8 + Math.floor(Math.random()*(width-16));
                const sy = 15 + Math.floor(Math.random()*3);
                const sl = 3 + Math.floor(Math.random()*8);
                spikes(sx, sy, sl);
            }

            // Random springs
            for (let i=0;i<12;i++){
                const sx = 8 + Math.floor(Math.random()*(width-16));
                const sy = 14 + Math.floor(Math.random()*4);
                tiles[sy*width + sx] = 5;
            }

            const spawn = { x: 2*TILE, y: 10*TILE };
            const goal = { x: (width-4)*TILE, y: 16*TILE }; // unused in endless

            // Enemies (random patrollers on ground)
            const enemies = [];
            for (let i=0;i<12;i++){
                const ex = 10 + Math.floor(Math.random()*(width-20));
                const ey = 15 + Math.floor(Math.random()*2);
                enemies.push({ x: ex*TILE, y: ey*TILE-28, speed: (Math.random()<0.5?-1:1) * (70+Math.random()*90) });
            }

            // Coins random on platforms and air
            const coins = [];
            for (let i=0;i<28;i++){
                const cx = 6 + Math.floor(Math.random()*(width-12));
                const cy = 6 + Math.floor(Math.random()*10);
                coins.push({ x: cx*TILE, y: cy*TILE });
            }

            // Cannons placed on ground or platforms occasionally
            const cannons = [];
            for (let i=0;i<10;i++){
                const cx = 10 + Math.floor(Math.random()*(width-20));
                // Find top solid at this column to place cannon on floor
                let cy = 0;
                for (let y=0;y<height-1;y++){
                    if (tiles[(y+1)*width + cx] === 1 || tiles[(y+1)*width + cx] === 4){ cy = y; break; }
                }
                cannons.push({ x: cx*TILE, y: cy*TILE-28 });
            }


            const solids = tiles.map(t=> (t===1 || t===4)?1:0);
            return { width, height, tiles, spawn, goal, enemies, coins, oneWays, solids, cannons };
        }
    })();
    // Draw special eater (big mouth) during death animation
    function drawEater(ctx, eater){
        // Growth
        const growDur = 0.6;
        let scale = 1;
        if (eater.phase === 'grow') scale = 1 + Math.min(1, eater.t / growDur) * 2.5; else scale = 3.5;
        const w = eater.baseW * scale;
        const h = eater.baseH * scale * 1.2;
        const cx = eater.x + eater.baseW/2;
        const cy = eater.y + eater.baseH/2;
        ctx.save();
        ctx.translate(cx, cy);
        // Body
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(-w/2, -h/2, w, h);
        // Eyes
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(-w*0.3, -h*0.2, w*0.18, w*0.18);
        ctx.fillRect(w*0.12, -h*0.2, w*0.18, w*0.18);
        // Big mouth
        ctx.fillStyle = '#111827';
        const mouthH = h*0.55;
        ctx.fillRect(-w*0.45, -mouthH*0.1, w*0.9, mouthH);
        // Teeth
        ctx.fillStyle = '#f8fafc';
        const teeth = 6;
        for (let i=0;i<teeth;i++){
            const tx = -w*0.40 + (i/(teeth-1))*w*0.80;
            ctx.beginPath();
            ctx.moveTo(tx, -mouthH*0.1);
            ctx.lineTo(tx + w*0.05, -mouthH*0.1 + h*0.12);
            ctx.lineTo(tx - w*0.05, -mouthH*0.1 + h*0.12);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(tx, mouthH*0.9);
            ctx.lineTo(tx + w*0.05, mouthH*0.9 - h*0.12);
            ctx.lineTo(tx - w*0.05, mouthH*0.9 - h*0.12);
            ctx.closePath();
            ctx.fill();
        }
        ctx.restore();
    }
    </script>
    </body>
</html>
